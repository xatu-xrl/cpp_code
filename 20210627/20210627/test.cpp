#include<iostream>
using namespace std;

//类中的6个默认成员函数

//1.构造函数
//构造函数是一个特殊的成员函数，名字与类名相同, 创建类类型对象时由编译器自动调用，负责初始化对象内容，并且在对象的生命周期内只调用一次
// 
//1. 函数名与类名相同。
//2. 无返回值。
//3. 对象实例化时编译器自动调用对应的构造函数，不能显示调用
//4. 构造函数可以重载。
// 
// 无参数是一个默认构造 不写编译器会默认生成
// 一旦用户显式定义编译器将不再生成
// 全缺省函数也是默认构造函数 只能有一个默认构造
//
//class Date
//{
//public:
//	// 1.无参构造函数
//	Date()
//	{}
//	// 2.带参构造函数
//	Date(int year, int month, int day)
//	{
//		_year = year;
//		_month = month;
//		_day = day;
//	}
//private:
//	int _year;
//	int _month;
//	int _day;
//};
//void TestDate()
//{
//	Date d1; // 调用无参构造函数
//	Date d2(2015, 1, 1); // 调用带参的构造函数
//	//匹配哪个调用哪个
//	// 如果通过无参构造函数创建对象时，对象后面不要跟括号，否则就成了函数声明
//	// 以下代码的函数：声明了d3函数，该函数无参，返回一个日期类型的对象
//	Date d3();
//}

//构造函数的一种默认行为 如果有自定义成员
//默认的构造函数会自动调用 自定义成员 的默认构造，完成自定义成员的初始化


//析构函数
//对象在销毁时会自动调用析构函数，完成类的一些资源清理工作
//1. 析构函数名是在类名前加上字符 ~。
//3. 一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数。
//4. 对象生命周期结束时，C++编译系统系统自动调用析构函数
// 
// 编译器生成的默认析构函数，对会自定类型成员调用它的析构函数



// 
// 拷贝构造函数
// Date(const Date& d） 底层Date* d = &date
// 若未显示定义，系统生成默认的拷贝构造函数
// 默认的拷贝构造函数对象按内存存储按字节序完成拷贝，这种拷贝我们叫做浅拷贝，或者值拷贝
// 拷贝构造函数的参数只有一个且必须使用引用传参，使用传值方式会引发无穷递归调用
// 若是有资源的拷贝 需要显示定义
// 

//运算符重载
// 只能存在已经存在的运算符
// 如果运算符的参数都是内置类型 不可以修改内置类型的逻辑
// 作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的操作符有一个默认的形参this，限定为第一个形参 this指向了第一个参数
//  .* 、:: 、sizeof 、?: 、. 注意以上5个运算符不能重载
class Date
{
public:
	Date(int y = 1, int m = 1, int d = 1)
	{
		_y = y;
		_m = m;
		_d = d;
	}
	bool operator==(const Date& d)
	{}
private:
	int _y;
	int _m;
	int _d;
};
//函数名 ： operator==

void test()
{
	Date d1(2021, 7, 2);
	Date d2(2021, 8, 2);
	if (d1.operator == (d2))
	{

	}
}

//赋值运算符重载 编译器自动调用 修改已经存在的对象内容 可以简写 d2 = d1
//想要进行连续赋值 返回值类型得是当前类型 不能为空
//有资源 显式定义 显示拷贝构造

//将const修饰的类成员函数称之为const成员函数，const修饰类成员函数，实际修饰该成员函数隐含的this指针，表明在该成员函数中不能对类的任何成员进行修改
//所以const只修饰成员函数
//const对象不可以调用非const成员函数
//非const对象可以调用const成员函数
//const成员函数内不可以调用其它的非const成员函数 因为权限被放大了
//非const成员函数内可以调用其它的const成员函数

//取地址重载 