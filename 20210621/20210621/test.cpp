#include<iostream>
using namespace std;
void Test()
{
	int a = 10;
	int& ra = a;// ra是一个引用：是a的别名，指向和a相同的实体
	printf("%p\n", &a);
	printf("%p\n", &ra);
}
//1.得初始化
//2.一个变量可以拥有多个引用
//3.一旦引用，不可以指向其他实体

//常引用 引用指向的实体（加const）不能被修改 
void test()
{
	const int a = 10;

	const int& ra = a;
	const int& ra1 = 100;

	double d = 2.0;
	const int& ra3 = d;

	//此时 d会创建一个整形的临时变量 d会存放进去 ra3也指向临时变量
	//查看地址 d的地址和ra3的地址是不同的
	//临时变量具有常性
}

//使用
//1.当参数
//2.做返回值 保证返回值的生命周期大于函数生命周期

//引用的底层实现 就是通过指针实现的 ，就是引用就是指针
//引用本身是由空间的，空间的大小和指针大小相同，不会去开所指向实体的空间
//编译器在引用的时候，编译器在底层自动解引用

//1. 引用在定义时必须初始化，指针没有要求
//2. 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型
//实体
//3. 没有NULL引用，但有NULL指针
//4. 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占
//	4个字节)
//5. 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小
//6. 有多级指针，但是没有多级引用
//7. 访问实体方式不同，指针需要显式解引用，引用编译器自己处理
//8. 引用比指针使用起来相对更安全

//inline 内联函数
//如果是太复杂的函数 就不起作用了
//nline不建议声明和定义分离，分离会导致链接错误。因为inline被展开，就没有函数地址了，链接就会找不到

//宏的优缺点？
//优点：
//1.增强代码的复用性。
//2.提高性能。
//缺点：
//1.不方便调试宏。（因为预编译阶段进行了替换）
//2.导致代码可读性差，可维护性差，容易误用。
//3.没有类型安全的检查 。
//C++有哪些技术替代宏？
//1. 常量定义 换用const
//2. 函数定义 换用内联函数

//auto 
//用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时则必须加&
//自动类型推导
//当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器实际只对
//第一个类型进行推导，然后用推导出来的类型定义其他变量。
void test()
{
	auto a = 10;//可以在编译的时候自动确定需要什么类型
	 
}

//范围for 当前的数据 ： 循环的范围
//更安全

void test2()
{
	int arr[] = { 1,2,3,4,5,6,7,8,9 };
	for (const auto& e : arr)//防止被修改
	{
		cout << e << " ";
		cout << endl;
	}
}

//注意在函数当中传入数组名 就有问题

//指针空值
void test()
{
	int* p = NULL;//预处理，宏替换 可以说是0 或者无乐星指针的常量 如果按照指针方式来使用 强转（void*)0
	int* p2 = 0;
	//建议使用nullptr
}
//在C++11中，sizeof(nullptr) 与 sizeof((void*)0)所占的字节数相同。